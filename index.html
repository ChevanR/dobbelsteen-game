<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>WebGL Interactieve Dobbelsteen</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #222; }
        #score {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 24px;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px 20px;
            border-radius: 8px;
            font-family: Arial, sans-serif;
        }
    </style>
</head>
<body>
    <canvas id="myCanvas" width="800" height="600"></canvas>
    <div id="score">Score: 0</div>
    <script type="text/javascript">
        // Constants
        const ROTATION_SPEED = 0.005; // Basis rotatiesnelheid

        // Base64 Textures voor elke zijde van de dobbelsteen
        const textureData = [
            // Die 1: Rood
            "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABkCAIAAAD/gAIDAAAAGXRFWHRTb2Z0d2FyZQB3d3cuaW5rc2NhcGUub3Jnm+48GgAAABl0RVh0Q3JlYXRpb24gVGltZQAwNi8wNS8xOb6J/uoAAAAcdEVYdFNvZnR3YXJlAHRvZGF5cGxheQAyLjAwMDAwMgKpL2UAAAEJSURBVHja7NExAQAAAMKg909tDjegAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD4DfwAG1VvQnAAAAAElFTkSuQmCC",
            // Die 2: Groen
            "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABkCAIAAAD/gAIDAAAAGXRFWHRTb2Z0d2FyZQB3d3cuaW5rc2NhcGUub3Jnm+48GgAAABl0RVh0Q3JlYXRpb24gVGltZQAwNi8wNS8xOb6J/uoAAAAcdEVYdFNvZnR3YXJlAHRvZGF5cGxheQAyLjAwMDAwMgKpL2UAAAEHSURBVHja7NExAQAAAMKg909tDjegAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD4DfwAG1VvQnAAAAAElFTkSuQmCC",
            // Die 3: Blauw
            "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABkCAIAAAD/gAIDAAAAGXRFWHRTb2Z0d2FyZQB3d3cuaW5rc2NhcGUub3Jnm+48GgAAABl0RVh0Q3JlYXRpb24gVGltZQAwNi8wNS8xOb6J/uoAAAAcdEVYdFNvZnR3YXJlAHRvZGF5cGxheQAyLjAwMDAwMgKpL2UAAAEISURBVHja7NExAQAAAMKg909tDjegAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD4DfwAG1VvQnAAAAAElFTkSuQmCC",
            // Die 4: Geel
            "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABkCAIAAAD/gAIDAAAAGXRFWHRTb2Z0d2FyZQB3d3cuaW5rc2NhcGUub3Jnm+48GgAAABl0RVh0Q3JlYXRpb24gVGltZQAwNi8wNS8xOb6J/uoAAAAcdEVYdFNvZnR3YXJlAHRvZGF5cGxheQAyLjAwMDAwMgKpL2UAAAEKSURBVHja7NExAQAAAMKg909tDjegAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD4DfwAG1VvQnAAAAAElFTkSuQmCC",
            // Die 5: Paars
            "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABkCAIAAAD/gAIDAAAAGXRFWHRTb2Z0d2FyZQB3d3cuaW5rc2NhcGUub3Jnm+48GgAAABl0RVh0Q3JlYXRpb24gVGltZQAwNi8wNS8xOb6J/uoAAAAcdEVYdFNvZnR3YXJlAHRvZGF5cGxheQAyLjAwMDAwMgKpL2UAAAEKSURBVHja7NExAQAAAMKg909tDjegAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD4DfwAG1VvQnAAAAAElFTkSuQmCC",
            // Die 6: Oranje
            "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABkCAIAAAD/gAIDAAAAGXRFWHRTb2Z0d2FyZQB3d3cuaW5rc2NhcGUub3Jnm+48GgAAABl0RVh0Q3JlYXRpb24gVGltZQAwNi8wNS8xOb6J/uoAAAAcdEVYdFNvZnR3YXJlAHRvZGF5cGxheQAyLjAwMDAwMgKpL2UAAAEKSURBVHja7NExAQAAAMKg909tDjegAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD4DfwAG1VvQnAAAAAElFTkSuQmCC"
        ];

        // Global Variables
        let glContext;
        let program;
        let canvas;
        let score = 0;
        let isRolling = false;
        let targetRotation = { x: 0, y: 0 };
        let currentRotation = { x: 0, y: 0 };
        let textures = [];
        let lastTime = 0;

        // Uniform Locations
        let uProjection, uTranslation, uRotationX, uRotationY;
        let uLightPos, uAmbient, uDiffuse, uSpecular;

        // HTML Elements
        const scoreElement = document.getElementById("score");

        // Initialisatie bij het laden van de pagina
        window.onload = function() {
            canvas = document.getElementById("myCanvas");
            glContext = canvas.getContext("webgl2");
            if (!glContext) {
                alert("WebGL 2.0 is niet beschikbaar.");
                return;
            }

            glContext.enable(glContext.DEPTH_TEST);
            glContext.clearColor(0.1, 0.1, 0.1, 1.0);

            initializeShaders();
            initializeBuffers();
            loadTextures();
            initializeMatrices();
            initializeLighting();
            initializeEvents();

            requestAnimationFrame(render);
        };

        // Shader Initialisatie
        function initializeShaders() {
            const vsSource = `#version 300 es
            in vec3 aPos;
            in vec3 aNormal;
            in vec2 aTexCoord;

            uniform mat4 uProjection;
            uniform mat4 uTranslation;
            uniform float uRotationX;
            uniform float uRotationY;

            out vec3 Normal;
            out vec3 FragPos;
            out vec2 TexCoord;

            void main() {
                // Rotatie rond X-as
                mat4 rotationX = mat4(
                    1.0, 0.0, 0.0, 0.0,
                    0.0, cos(uRotationX), sin(uRotationX), 0.0,
                    0.0, -sin(uRotationX), cos(uRotationX), 0.0,
                    0.0, 0.0, 0.0, 1.0
                );

                // Rotatie rond Y-as
                mat4 rotationY = mat4(
                    cos(uRotationY), 0.0, -sin(uRotationY), 0.0,
                    0.0, 1.0, 0.0, 0.0,
                    sin(uRotationY), 0.0, cos(uRotationY), 0.0,
                    0.0, 0.0, 0.0, 1.0
                );

                mat4 rotation = rotationY * rotationX;
                mat4 model = uTranslation * rotation;

                gl_Position = uProjection * model * vec4(aPos, 1.0);
                FragPos = vec3(model * vec4(aPos, 1.0));
                Normal = mat3(transpose(inverse(model))) * aNormal;
                TexCoord = aTexCoord;
            }`;

            const fsSource = `#version 300 es
            precision mediump float;

            in vec3 Normal;
            in vec3 FragPos;
            in vec2 TexCoord;

            uniform sampler2D uTexture1;
            uniform sampler2D uTexture2;
            uniform sampler2D uTexture3;
            uniform sampler2D uTexture4;
            uniform sampler2D uTexture5;
            uniform sampler2D uTexture6;

            uniform vec3 uLightPos;
            uniform float uAmbient;
            uniform float uDiffuse;
            uniform float uSpecular;

            out vec4 FragColor;

            void main() {
                vec4 texColor;

                // Bepaal welke zijde we bekijken op basis van de normale vector
                if (abs(Normal.x - 1.0) < 0.001) {
                    texColor = texture(uTexture1, TexCoord);
                } else if (abs(Normal.x + 1.0) < 0.001) {
                    texColor = texture(uTexture2, TexCoord);
                } else if (abs(Normal.y - 1.0) < 0.001) {
                    texColor = texture(uTexture3, TexCoord);
                } else if (abs(Normal.y + 1.0) < 0.001) {
                    texColor = texture(uTexture4, TexCoord);
                } else if (abs(Normal.z - 1.0) < 0.001) {
                    texColor = texture(uTexture5, TexCoord);
                } else {
                    texColor = texture(uTexture6, TexCoord);
                }

                // Belichting berekeningen
                vec3 norm = normalize(Normal);
                vec3 lightDir = normalize(uLightPos - FragPos);
                float diff = max(dot(norm, lightDir), 0.0);

                vec3 viewDir = normalize(-FragPos);
                vec3 reflectDir = reflect(-lightDir, norm);
                float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32.0);

                vec3 ambient = uAmbient * vec3(texColor);
                vec3 diffuse = uDiffuse * diff * vec3(texColor);
                vec3 specular = uSpecular * spec * vec3(1.0);

                vec3 finalColor = ambient + diffuse + specular;
                FragColor = vec4(finalColor, texColor.a);
            }`;

            const vertexShader = compileShader(glContext.VERTEX_SHADER, vsSource);
            const fragmentShader = compileShader(glContext.FRAGMENT_SHADER, fsSource);

            program = glContext.createProgram();
            glContext.attachShader(program, vertexShader);
            glContext.attachShader(program, fragmentShader);
            glContext.linkProgram(program);

            if (!glContext.getProgramParameter(program, glContext.LINK_STATUS)) {
                console.error("Shader programma mislukt:", glContext.getProgramInfoLog(program));
                return;
            }

            glContext.useProgram(program);
        }

        function compileShader(type, source) {
            const shader = glContext.createShader(type);
            glContext.shaderSource(shader, source);
            glContext.compileShader(shader);
            if (!glContext.getShaderParameter(shader, glContext.COMPILE_STATUS)) {
                console.error("Shader compilatie mislukt:", glContext.getShaderInfoLog(shader));
                glContext.deleteShader(shader);
                return null;
            }
            return shader;
        }

        // Buffer Initialisatie
        let vao;
        function initializeBuffers() {
            vao = glContext.createVertexArray();
            glContext.bindVertexArray(vao);

            // Definieer de vertices van de kubus met posities, normals en TexCoords
            const vertices = new Float32Array([
                // Posities         // Normals          // TexCoords
                // Front face (die1.png: Rood)
                1,  1,  1,          0,  0,  1,           1, 1,
                1, -1,  1,          0,  0,  1,           1, 0,
               -1, -1,  1,          0,  0,  1,           0, 0,
               -1, -1,  1,          0,  0,  1,           0, 0,
               -1,  1,  1,          0,  0,  1,           0, 1,
                1,  1,  1,          0,  0,  1,           1, 1,

                // Back face (die2.png: Groen)
                1,  1, -1,          0,  0, -1,           1, 1,
                1, -1, -1,          0,  0, -1,           1, 0,
               -1, -1, -1,          0,  0, -1,           0, 0,
               -1, -1, -1,          0,  0, -1,           0, 0,
               -1,  1, -1,          0,  0, -1,           0, 1,
                1,  1, -1,          0,  0, -1,           1, 1,

                // Right face (die3.png: Blauw)
                1,  1,  1,          1,  0,  0,           1, 1,
                1, -1,  1,          1,  0,  0,           1, 0,
                1, -1, -1,          1,  0,  0,           0, 0,
                1, -1, -1,          1,  0,  0,           0, 0,
                1,  1, -1,          1,  0,  0,           0, 1,
                1,  1,  1,          1,  0,  0,           1, 1,

                // Left face (die4.png: Geel)
               -1,  1,  1,         -1,  0,  0,           1, 1,
               -1, -1,  1,         -1,  0,  0,           1, 0,
               -1, -1, -1,         -1,  0,  0,           0, 0,
               -1, -1, -1,         -1,  0,  0,           0, 0,
               -1,  1, -1,         -1,  0,  0,           0, 1,
               -1,  1,  1,         -1,  0,  0,           1, 1,

                // Top face (die5.png: Paars)
                1,  1,  1,          0,  1,  0,           1, 1,
               -1,  1,  1,          0,  1,  0,           1, 1,
               -1,  1, -1,          0,  1,  0,           0, 1,
               -1,  1, -1,          0,  1,  0,           0, 1,
                1,  1, -1,          0,  1,  0,           0, 1,
                1,  1,  1,          0,  1,  0,           1, 1,

                // Bottom face (die6.png: Oranje)
                1, -1,  1,          0, -1,  0,           1, 1,
               -1, -1,  1,          0, -1,  0,           1, 1,
               -1, -1, -1,          0, -1,  0,           0, 1,
               -1, -1, -1,          0, -1,  0,           0, 1,
                1, -1, -1,          0, -1,  0,           0, 1,
                1, -1,  1,          0, -1,  0,           1, 1,
            ]);

            const buffer = glContext.createBuffer();
            glContext.bindBuffer(glContext.ARRAY_BUFFER, buffer);
            glContext.bufferData(glContext.ARRAY_BUFFER, vertices, glContext.STATIC_DRAW);

            // Position attrib
            const aPos = glContext.getAttribLocation(program, "aPos");
            glContext.enableVertexAttribArray(aPos);
            glContext.vertexAttribPointer(aPos, 3, glContext.FLOAT, false, 32, 0);

            // Normal attrib
            const aNormal = glContext.getAttribLocation(program, "aNormal");
            glContext.enableVertexAttribArray(aNormal);
            glContext.vertexAttribPointer(aNormal, 3, glContext.FLOAT, false, 32, 12);

            // TexCoord attrib
            const aTexCoord = glContext.getAttribLocation(program, "aTexCoord");
            glContext.enableVertexAttribArray(aTexCoord);
            glContext.vertexAttribPointer(aTexCoord, 2, glContext.FLOAT, false, 32, 24);
        }

        // Textures Laden
        function loadTextures() {
            const textureUnits = ["uTexture1", "uTexture2", "uTexture3", "uTexture4", "uTexture5", "uTexture6"];

            for (let i = 0; i < textureData.length; i++) {
                const texture = glContext.createTexture();
                glContext.bindTexture(glContext.TEXTURE_2D, texture);

                // Placeholder 1x1 pixel
                const level = 0;
                const internalFormat = glContext.RGBA;
                const width = 1;
                const height = 1;
                const border = 0;
                const srcFormat = glContext.RGBA;
                const srcType = glContext.UNSIGNED_BYTE;
                const pixel = new Uint8Array([255, 255, 255, 255]); // Witte pixel
                glContext.texImage2D(glContext.TEXTURE_2D, level, internalFormat, width, height, border, srcFormat, srcType, pixel);

                // Laad de daadwerkelijke afbeelding
                const image = new Image();
                image.src = textureData[i];
                image.onload = function() {
                    glContext.bindTexture(glContext.TEXTURE_2D, texture);
                    glContext.texImage2D(glContext.TEXTURE_2D, level, internalFormat, srcFormat, srcType, image);
                    glContext.generateMipmap(glContext.TEXTURE_2D);
                };
                image.onerror = function() {
                    console.error(`Fout bij het laden van de texture ${i + 1}`);
                };

                // Texture parameters
                glContext.texParameteri(glContext.TEXTURE_2D, glContext.TEXTURE_WRAP_S, glContext.CLAMP_TO_EDGE);
                glContext.texParameteri(glContext.TEXTURE_2D, glContext.TEXTURE_WRAP_T, glContext.CLAMP_TO_EDGE);
                glContext.texParameteri(glContext.TEXTURE_2D, glContext.TEXTURE_MIN_FILTER, glContext.LINEAR_MIPMAP_LINEAR);
                glContext.texParameteri(glContext.TEXTURE_2D, glContext.TEXTURE_MAG_FILTER, glContext.LINEAR);

                // Activeer de juiste texture unit en wijs de texture toe
                glContext.activeTexture(glContext.TEXTURE0 + i);
                glContext.bindTexture(glContext.TEXTURE_2D, texture);
                glContext.uniform1i(glContext.getUniformLocation(program, textureUnits[i]), i);
            }
        }

        // Matrix Initialisatie
        function initializeMatrices() {
            // Projection matrix (perspectief)
            uProjection = glContext.getUniformLocation(program, "uProjection");
            const fov = 45 * Math.PI / 180; // 45 graden
            const aspect = glContext.canvas.clientWidth / glContext.canvas.clientHeight;
            const zNear = 0.1;
            const zFar = 100.0;
            const projectionMatrix = perspective(fov, aspect, zNear, zFar);
            glContext.uniformMatrix4fv(uProjection, false, projectionMatrix);

            // Translation matrix
            uTranslation = glContext.getUniformLocation(program, "uTranslation");
            const translationMatrix = translate(0, 0, -6);
            glContext.uniformMatrix4fv(uTranslation, false, translationMatrix);
        }

        // Belichting Initialisatie
        function initializeLighting() {
            uLightPos = glContext.getUniformLocation(program, "uLightPos");
            uAmbient = glContext.getUniformLocation(program, "uAmbient");
            uDiffuse = glContext.getUniformLocation(program, "uDiffuse");
            uSpecular = glContext.getUniformLocation(program, "uSpecular");

            // Initiale waarden
            glContext.uniform3fv(uLightPos, [5.0, 5.0, 5.0]);
            glContext.uniform1f(uAmbient, 0.3);
            glContext.uniform1f(uDiffuse, 0.7);
            glContext.uniform1f(uSpecular, 1.0);
        }

        // Evenementen Initialisatie
        function initializeEvents() {
            // Spatiebalk om te rollen
            window.addEventListener("keydown", function(event) {
                if (event.code === "Space" && !isRolling) {
                    rollDie();
                }
            });

            // Muis bewegen om de lichtbron aan te passen
            canvas.addEventListener("mousemove", function(event) {
                const rect = canvas.getBoundingClientRect();
                const x = ((event.clientX - rect.left) / canvas.width) * 10 - 5; // Van -5 tot +5
                const y = ((event.clientY - rect.top) / canvas.height) * 10 - 5; // Van -5 tot +5
                glContext.uniform3fv(uLightPos, [x, y, 5.0]);
            });

            // Toetsenbord controles voor belichting
            window.addEventListener("keydown", function(event) {
                switch (event.key) {
                    case "a": // Verhoog ambient
                        let currentAmbient = glContext.getUniform(program, uAmbient);
                        glContext.uniform1f(uAmbient, Math.min(1.0, currentAmbient + 0.05));
                        break;
                    case "z": // Verlaag ambient
                        let currentAmbientZ = glContext.getUniform(program, uAmbient);
                        glContext.uniform1f(uAmbient, Math.max(0.0, currentAmbientZ - 0.05));
                        break;
                    case "s": // Verhoog diffuse
                        let currentDiffuse = glContext.getUniform(program, uDiffuse);
                        glContext.uniform1f(uDiffuse, Math.min(5.0, currentDiffuse + 0.05));
                        break;
                    case "x": // Verlaag diffuse
                        let currentDiffuseX = glContext.getUniform(program, uDiffuse);
                        glContext.uniform1f(uDiffuse, Math.max(0.0, currentDiffuseX - 0.05));
                        break;
                    case "d": // Verhoog specular
                        let currentSpecular = glContext.getUniform(program, uSpecular);
                        glContext.uniform1f(uSpecular, Math.min(5.0, currentSpecular + 0.05));
                        break;
                    case "c": // Verlaag specular
                        let currentSpecularC = glContext.getUniform(program, uSpecular);
                        glContext.uniform1f(uSpecular, Math.max(0.0, currentSpecularC - 0.05));
                        break;
                }
            });
        }

        // Render Functie
        function render(currentTime) {
            const deltaTime = currentTime - lastTime;
            lastTime = currentTime;

            glContext.clear(glContext.COLOR_BUFFER_BIT | glContext.DEPTH_BUFFER_BIT);

            // Automatische rotatie als niet aan het rollen
            if (!isRolling) {
                currentRotation.x += ROTATION_SPEED;
                currentRotation.y += ROTATION_SPEED;
            }

            // Update rotatie uniformen
            const uRotationX = glContext.getUniformLocation(program, "uRotationX");
            const uRotationY = glContext.getUniformLocation(program, "uRotationY");
            glContext.uniform1f(uRotationX, currentRotation.x);
            glContext.uniform1f(uRotationY, currentRotation.y);

            // Bind texturen
            for (let i = 0; i < textures.length; i++) {
                glContext.activeTexture(glContext.TEXTURE0 + i);
                glContext.bindTexture(glContext.TEXTURE_2D, textures[i]);
            }

            // Render de kubus (dobbelsteen)
            glContext.bindVertexArray(vao);
            glContext.drawArrays(glContext.TRIANGLES, 0, 36);

            requestAnimationFrame(render);
        }

        // Dobbelsteen Rollen
        function rollDie() {
            isRolling = true;

            // Genereer een willekeurig nummer tussen 1 en 6
            const randomNumber = Math.floor(Math.random() * 6) + 1;
            console.log(`Gegooid: ${randomNumber}`);

            // Update score
            score += randomNumber;
            scoreElement.innerText = `Score: ${score}`;

            // Bepaal de eindrotatie zodat de juiste zijde naar boven komt
            // Dit is vereenvoudigd en kan worden aangepast voor nauwkeurigere uitlijning
            const rotations = {
                1: { x: 0, y: 0 },
                2: { x: Math.PI / 2, y: 0 },
                3: { x: Math.PI, y: 0 },
                4: { x: -Math.PI / 2, y: 0 },
                5: { x: 0, y: Math.PI / 2 },
                6: { x: 0, y: -Math.PI / 2 }
            };

            const target = rotations[randomNumber];
            targetRotation.x = currentRotation.x + target.x + (Math.random() * Math.PI * 4); // Extra rotaties voor realisme
            targetRotation.y = currentRotation.y + target.y + (Math.random() * Math.PI * 4);

            // Animatie functie
            function animate() {
                let needAnotherFrame = false;

                if (currentRotation.x < targetRotation.x) {
                    currentRotation.x += ROTATION_SPEED * 10;
                    if (currentRotation.x < targetRotation.x) needAnotherFrame = true;
                    glContext.uniform1f(uRotationX, currentRotation.x);
                }

                if (currentRotation.y < targetRotation.y) {
                    currentRotation.y += ROTATION_SPEED * 10;
                    if (currentRotation.y < targetRotation.y) needAnotherFrame = true;
                    glContext.uniform1f(uRotationY, currentRotation.y);
                }

                // Render de kubus opnieuw
                glContext.clear(glContext.COLOR_BUFFER_BIT | glContext.DEPTH_BUFFER_BIT);
                for (let i = 0; i < textures.length; i++) {
                    glContext.activeTexture(glContext.TEXTURE0 + i);
                    glContext.bindTexture(glContext.TEXTURE_2D, textures[i]);
                }
                glContext.bindVertexArray(vao);
                glContext.drawArrays(glContext.TRIANGLES, 0, 36);

                if (needAnotherFrame) {
                    requestAnimationFrame(animate);
                } else {
                    isRolling = false;
                }
            }

            requestAnimationFrame(animate);
        }

        // Matrix Hulpfuncties
        function perspective(fov, aspect, near, far) {
            const f = 1.0 / Math.tan(fov / 2);
            const nf = 1 / (near - far);
            const out = new Float32Array(16);
            out[0] = f / aspect;
            out[1] = 0;
            out[2] = 0;
            out[3] = 0;
            out[4] = 0;
            out[5] = f;
            out[6] = 0;
            out[7] = 0;
            out[8] = 0;
            out[9] = 0;
            out[10] = (far + near) * nf;
            out[11] = -1;
            out[12] = 0;
            out[13] = 0;
            out[14] = (2 * far * near) * nf;
            out[15] = 0;
            return out;
        }

        function translate(x, y, z) {
            const out = new Float32Array(16);
            out[0] = 1;
            out[1] = 0;
            out[2] = 0;
            out[3] = 0;
            out[4] = 0;
            out[5] = 1;
            out[6] = 0;
            out[7] = 0;
            out[8] = 0;
            out[9] = 0;
            out[10] = 1;
            out[11] = 0;
            out[12] = x;
            out[13] = y;
            out[14] = z;
            out[15] = 1;
            return out;
        }
    </script>
</body>
</html>
