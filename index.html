<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>WebGL Interactieve Dobbelsteen</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #222; color: white; font-family: Arial, sans-serif; }
        #scoreboard {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 8px;
        }
        #scoreboard h2 {
            margin-top: 0;
        }
        #scoreboard ul {
            list-style: none;
            padding: 0;
        }
        #scoreboard li {
            margin-bottom: 10px;
        }
        #scoreboard button {
            margin-left: 10px;
        }
        #playerForm {
            margin-bottom: 20px;
        }
        #playerForm input {
            padding: 5px;
            font-size: 14px;
        }
        #playerForm button {
            padding: 5px 10px;
            font-size: 14px;
        }
        #activePlayer {
            font-weight: bold;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <canvas id="myCanvas" width="800" height="600"></canvas>
    <div id="scoreboard">
        <h2>Scoreboard</h2>
        <form id="playerForm">
            <input type="text" id="playerName" placeholder="Enter player name" required />
            <button type="submit">Add Player</button>
        </form>
        <ul id="playersList">
            <!-- Spelers worden hier toegevoegd -->
        </ul>
        <div id="activePlayer">Active Player: None</div>
    </div>
    <script type="text/javascript">
        // Constants
        const ROTATION_SPEED = 0.005; // Basis rotatiesnelheid

        // Base64 Textures voor elke zijde van de dobbelsteen
        const textureData = [
            // Die 1: Rood
            "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8z8AARQUBXH39QXwAAAAASUVORK5CYII=",
            // Die 2: Groen
            "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=",
            // Die 3: Blauw
            "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/AwAC/AL+EHcUAAAAAElFTkSuQmCC",
            // Die 4: Geel
            "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNk+A8AAwMB/6S0IMkAAAAASUVORK5CYII=",
            // Die 5: Paars
            "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNk+A8AAwMB/6S0IMkAAAAASUVORK5CYII=",
            // Die 6: Oranje
            "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNk+A8AAwMB/6S0IMkAAAAASUVORK5CYII="
        ];

        // Global Variables
        let glContext;
        let program;
        let canvas;
        let players = []; // Array van spelers
        let activePlayerIndex = 0; // Index van de actieve speler
        let isRolling = false;
        let targetRotation = { x: 0, y: 0 };
        let currentRotation = { x: 0, y: 0 };
        let textures = [];
        let lastTime = 0;

        // Uniform Locations
        let uProjection, uTranslation, uRotationX, uRotationY;
        let uLightPos, uAmbient, uDiffuse, uSpecular;

        // HTML Elements
        const scoreboard = document.getElementById("scoreboard");
        const playerForm = document.getElementById("playerForm");
        const playersList = document.getElementById("playersList");
        const activePlayerDiv = document.getElementById("activePlayer");

        // Initialisatie bij het laden van de pagina
        window.onload = function() {
            canvas = document.getElementById("myCanvas");
            glContext = canvas.getContext("webgl2");
            if (!glContext) {
                alert("WebGL 2.0 is niet beschikbaar.");
                return;
            }

            glContext.enable(glContext.DEPTH_TEST);
            glContext.clearColor(0.1, 0.1, 0.1, 1.0);

            initializeShaders();
            initializeBuffers();
            loadTextures();
            initializeMatrices();
            initializeLighting();
            initializeEvents();

            requestAnimationFrame(render);
        };

        // Shader Initialisatie
        function initializeShaders() {
            const vsSource = `#version 300 es
            in vec3 aPos;
            in vec3 aNormal;
            in vec2 aTexCoord;
            in float aFaceID;

            uniform mat4 uProjection;
            uniform mat4 uTranslation;
            uniform float uRotationX;
            uniform float uRotationY;

            out vec3 Normal;
            out vec3 FragPos;
            out vec2 TexCoord;
            out float FaceID;

            void main() {
                // Rotatie rond X-as
                mat4 rotationX = mat4(
                    1.0, 0.0, 0.0, 0.0,
                    0.0, cos(uRotationX), sin(uRotationX), 0.0,
                    0.0, -sin(uRotationX), cos(uRotationX), 0.0,
                    0.0, 0.0, 0.0, 1.0
                );

                // Rotatie rond Y-as
                mat4 rotationY = mat4(
                    cos(uRotationY), 0.0, -sin(uRotationY), 0.0,
                    0.0, 1.0, 0.0, 0.0,
                    sin(uRotationY), 0.0, cos(uRotationY), 0.0,
                    0.0, 0.0, 0.0, 1.0
                );

                mat4 rotation = rotationY * rotationX;
                mat4 model = uTranslation * rotation;

                gl_Position = uProjection * model * vec4(aPos, 1.0);
                FragPos = vec3(model * vec4(aPos, 1.0));
                Normal = mat3(transpose(inverse(model))) * aNormal;
                TexCoord = aTexCoord;
                FaceID = aFaceID;
            }`;

            const fsSource = `#version 300 es
            precision mediump float;

            in vec3 Normal;
            in vec3 FragPos;
            in vec2 TexCoord;
            in float FaceID;

            uniform sampler2D uTexture1;
            uniform sampler2D uTexture2;
            uniform sampler2D uTexture3;
            uniform sampler2D uTexture4;
            uniform sampler2D uTexture5;
            uniform sampler2D uTexture6;

            uniform vec3 uLightPos;
            uniform float uAmbient;
            uniform float uDiffuse;
            uniform float uSpecular;

            out vec4 FragColor;

            void main() {
                vec4 texColor;

                // Bepaal welke zijde we bekijken op basis van FaceID
                if (FaceID < 1.5) {
                    texColor = texture(uTexture1, TexCoord);
                } else if (FaceID < 2.5) {
                    texColor = texture(uTexture2, TexCoord);
                } else if (FaceID < 3.5) {
                    texColor = texture(uTexture3, TexCoord);
                } else if (FaceID < 4.5) {
                    texColor = texture(uTexture4, TexCoord);
                } else if (FaceID < 5.5) {
                    texColor = texture(uTexture5, TexCoord);
                } else {
                    texColor = texture(uTexture6, TexCoord);
                }

                // Belichting berekeningen
                vec3 norm = normalize(Normal);
                vec3 lightDir = normalize(uLightPos - FragPos);
                float diff = max(dot(norm, lightDir), 0.0);

                vec3 viewDir = normalize(-FragPos);
                vec3 reflectDir = reflect(-lightDir, norm);
                float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32.0);

                vec3 ambient = uAmbient * vec3(texColor);
                vec3 diffuse = uDiffuse * diff * vec3(texColor);
                vec3 specular = uSpecular * spec * vec3(1.0);

                vec3 finalColor = ambient + diffuse + specular;
                FragColor = vec4(finalColor, texColor.a);
            }`;

            const vertexShader = compileShader(glContext.VERTEX_SHADER, vsSource);
            const fragmentShader = compileShader(glContext.FRAGMENT_SHADER, fsSource);

            if (!vertexShader || !fragmentShader) {
                console.error("Fout bij het compileren van shaders.");
                return;
            }

            program = glContext.createProgram();
            glContext.attachShader(program, vertexShader);
            glContext.attachShader(program, fragmentShader);
            glContext.linkProgram(program);

            if (!glContext.getProgramParameter(program, glContext.LINK_STATUS)) {
                console.error("Shader programma mislukt:", glContext.getProgramInfoLog(program));
                return;
            }

            glContext.useProgram(program);
        }

        function compileShader(type, source) {
            const shader = glContext.createShader(type);
            glContext.shaderSource(shader, source);
            glContext.compileShader(shader);
            if (!glContext.getShaderParameter(shader, glContext.COMPILE_STATUS)) {
                console.error("Shader compilatie mislukt:", glContext.getShaderInfoLog(shader));
                glContext.deleteShader(shader);
                return null;
            }
            return shader;
        }

        // Buffer Initialisatie
        let vao;
        function initializeBuffers() {
            vao = glContext.createVertexArray();
            glContext.bindVertexArray(vao);

            // Definieer de vertices van de kubus met posities, normals, TexCoords en FaceID
            const vertices = new Float32Array([
                // Posities         // Normals          // TexCoords // FaceID
                // Front face (die1.png: Rood) FaceID = 1
                1,  1,  1,          0,  0,  1,           1, 1,        1,
                1, -1,  1,          0,  0,  1,           1, 0,        1,
               -1, -1,  1,          0,  0,  1,           0, 0,        1,
               -1, -1,  1,          0,  0,  1,           0, 0,        1,
               -1,  1,  1,          0,  0,  1,           0, 1,        1,
                1,  1,  1,          0,  0,  1,           1, 1,        1,

                // Back face (die2.png: Groen) FaceID = 2
                1,  1, -1,          0,  0, -1,           1, 1,        2,
                1, -1, -1,          0,  0, -1,           1, 0,        2,
               -1, -1, -1,          0,  0, -1,           0, 0,        2,
               -1, -1, -1,          0,  0, -1,           0, 0,        2,
               -1,  1, -1,          0,  0, -1,           0, 1,        2,
                1,  1, -1,          0,  0, -1,           1, 1,        2,

                // Right face (die3.png: Blauw) FaceID = 3
                1,  1,  1,          1,  0,  0,           1, 1,        3,
                1, -1,  1,          1,  0,  0,           1, 0,        3,
                1, -1, -1,          1,  0,  0,           0, 0,        3,
                1, -1, -1,          1,  0,  0,           0, 0,        3,
                1,  1, -1,          1,  0,  0,           0, 1,        3,
                1,  1,  1,          1,  0,  0,           1, 1,        3,

                // Left face (die4.png: Geel) FaceID = 4
               -1,  1,  1,         -1,  0,  0,           1, 1,        4,
               -1, -1,  1,         -1,  0,  0,           1, 0,        4,
               -1, -1, -1,         -1,  0,  0,           0, 0,        4,
               -1, -1, -1,         -1,  0,  0,           0, 0,        4,
               -1,  1, -1,         -1,  0,  0,           0, 1,        4,
               -1,  1,  1,         -1,  0,  0,           1, 1,        4,

                // Top face (die5.png: Paars) FaceID = 5
                1,  1,  1,          0,  1,  0,           1, 1,        5,
               -1,  1,  1,          0,  1,  0,           1, 0,        5,
               -1,  1, -1,          0,  1,  0,           0, 0,        5,
               -1,  1, -1,          0,  1,  0,           0, 0,        5,
                1,  1, -1,          0,  1,  0,           0, 1,        5,
                1,  1,  1,          0,  1,  0,           1, 1,        5,

                // Bottom face (die6.png: Oranje) FaceID = 6
                1, -1,  1,          0, -1,  0,           1, 1,        6,
               -1, -1,  1,          0, -1,  0,           1, 0,        6,
               -1, -1, -1,          0, -1,  0,           0, 0,        6,
               -1, -1, -1,          0, -1,  0,           0, 0,        6,
                1, -1, -1,          0, -1,  0,           0, 1,        6,
                1, -1,  1,          0, -1,  0,           1, 1,        6,
            ]);

            const buffer = glContext.createBuffer();
            glContext.bindBuffer(glContext.ARRAY_BUFFER, buffer);
            glContext.bufferData(glContext.ARRAY_BUFFER, vertices, glContext.STATIC_DRAW);

            // Position attrib
            const aPos = glContext.getAttribLocation(program, "aPos");
            glContext.enableVertexAttribArray(aPos);
            glContext.vertexAttribPointer(aPos, 3, glContext.FLOAT, false, 36, 0); // 9 floats * 4 bytes = 36 bytes

            // Normal attrib
            const aNormal = glContext.getAttribLocation(program, "aNormal");
            glContext.enableVertexAttribArray(aNormal);
            glContext.vertexAttribPointer(aNormal, 3, glContext.FLOAT, false, 36, 12); // 3 floats *4 = 12

            // TexCoord attrib
            const aTexCoord = glContext.getAttribLocation(program, "aTexCoord");
            glContext.enableVertexAttribArray(aTexCoord);
            glContext.vertexAttribPointer(aTexCoord, 2, glContext.FLOAT, false, 36, 24); // 2 floats *4 = 24

            // FaceID attrib
            const aFaceID = glContext.getAttribLocation(program, "aFaceID");
            glContext.enableVertexAttribArray(aFaceID);
            glContext.vertexAttribPointer(aFaceID, 1, glContext.FLOAT, false, 36, 32); // 1 float *4 = 32
        }

        // Textures Laden
        function loadTextures() {
            const textureUnits = ["uTexture1", "uTexture2", "uTexture3", "uTexture4", "uTexture5", "uTexture6"];

            for (let i = 0; i < textureData.length; i++) {
                const texture = glContext.createTexture();
                glContext.bindTexture(glContext.TEXTURE_2D, texture);

                // Placeholder 1x1 pixel
                const level = 0;
                const internalFormat = glContext.RGBA;
                const width = 1;
                const height = 1;
                const border = 0;
                const srcFormat = glContext.RGBA;
                const srcType = glContext.UNSIGNED_BYTE;
                const pixel = new Uint8Array([255, 255, 255, 255]); // Witte pixel
                glContext.texImage2D(glContext.TEXTURE_2D, level, internalFormat, width, height, border, srcFormat, srcType, pixel);

                // Laad de daadwerkelijke afbeelding
                const image = new Image();
                image.src = textureData[i];
                image.onload = function() {
                    glContext.bindTexture(glContext.TEXTURE_2D, texture);
                    glContext.texImage2D(glContext.TEXTURE_2D, level, internalFormat, srcFormat, srcType, image);
                    glContext.generateMipmap(glContext.TEXTURE_2D);
                };
                image.onerror = function() {
                    console.error(`Fout bij het laden van de texture ${i + 1}`);
                };

                // Texture parameters
                glContext.texParameteri(glContext.TEXTURE_2D, glContext.TEXTURE_WRAP_S, glContext.CLAMP_TO_EDGE);
                glContext.texParameteri(glContext.TEXTURE_2D, glContext.TEXTURE_WRAP_T, glContext.CLAMP_TO_EDGE);
                glContext.texParameteri(glContext.TEXTURE_2D, glContext.TEXTURE_MIN_FILTER, glContext.LINEAR_MIPMAP_LINEAR);
                glContext.texParameteri(glContext.TEXTURE_2D, glContext.TEXTURE_MAG_FILTER, glContext.LINEAR);

                // Activeer de juiste texture unit en wijs de texture toe
                glContext.activeTexture(glContext.TEXTURE0 + i);
                glContext.bindTexture(glContext.TEXTURE_2D, texture);
                glContext.uniform1i(glContext.getUniformLocation(program, textureUnits[i]), i);
                textures.push(texture);
            }
        }

        // Matrix Initialisatie
        function initializeMatrices() {
            // Projection matrix (perspectief)
            uProjection = glContext.getUniformLocation(program, "uProjection");
            const fov = 45 * Math.PI / 180; // 45 graden
            const aspect = glContext.canvas.clientWidth / glContext.canvas.clientHeight;
            const zNear = 0.1;
            const zFar = 100.0;
            const projectionMatrix = perspective(fov, aspect, zNear, zFar);
            glContext.uniformMatrix4fv(uProjection, false, projectionMatrix);

            // Translation matrix
            uTranslation = glContext.getUniformLocation(program, "uTranslation");
            const translationMatrix = translate(0, 0, -6);
            glContext.uniformMatrix4fv(uTranslation, false, translationMatrix);
        }

        // Belichting Initialisatie
        function initializeLighting() {
            uLightPos = glContext.getUniformLocation(program, "uLightPos");
            uAmbient = glContext.getUniformLocation(program, "uAmbient");
            uDiffuse = glContext.getUniformLocation(program, "uDiffuse");
            uSpecular = glContext.getUniformLocation(program, "uSpecular");

            // Initiale waarden
            glContext.uniform3fv(uLightPos, [5.0, 5.0, 5.0]);
            glContext.uniform1f(uAmbient, 0.3);
            glContext.uniform1f(uDiffuse, 0.7);
            glContext.uniform1f(uSpecular, 1.0);
        }

        // Evenementen Initialisatie
        function initializeEvents() {
            // Spatiebalk om te rollen
            window.addEventListener("keydown", function(event) {
                if (event.code === "Space" && !isRolling) {
                    rollDie();
                }
            });

            // Toetsenbord controles voor belichting
            window.addEventListener("keydown", function(event) {
                switch (event.key) {
                    case "a": // Verhoog ambient
                        let currentAmbient = glContext.getUniform(program, uAmbient);
                        glContext.uniform1f(uAmbient, Math.min(1.0, currentAmbient + 0.05));
                        break;
                    case "z": // Verlaag ambient
                        let currentAmbientZ = glContext.getUniform(program, uAmbient);
                        glContext.uniform1f(uAmbient, Math.max(0.0, currentAmbientZ - 0.05));
                        break;
                    case "s": // Verhoog diffuse
                        let currentDiffuse = glContext.getUniform(program, uDiffuse);
                        glContext.uniform1f(uDiffuse, Math.min(5.0, currentDiffuse + 0.05));
                        break;
                    case "x": // Verlaag diffuse
                        let currentDiffuseX = glContext.getUniform(program, uDiffuse);
                        glContext.uniform1f(uDiffuse, Math.max(0.0, currentDiffuseX - 0.05));
                        break;
                    case "d": // Verhoog specular
                        let currentSpecular = glContext.getUniform(program, uSpecular);
                        glContext.uniform1f(uSpecular, Math.min(5.0, currentSpecular + 0.05));
                        break;
                    case "c": // Verlaag specular
                        let currentSpecularC = glContext.getUniform(program, uSpecular);
                        glContext.uniform1f(uSpecular, Math.max(0.0, currentSpecularC - 0.05));
                        break;
                }
            });

            // Formulier voor toevoegen van spelers
            playerForm.addEventListener("submit", function(event) {
                event.preventDefault();
                const playerNameInput = document.getElementById("playerName");
                const name = playerNameInput.value.trim();
                if (name === "") return;

                // Controleer of de speler al bestaat
                if (players.some(player => player.name === name)) {
                    alert("Speler bestaat al!");
                    return;
                }

                // Voeg speler toe
                const player = { name: name, score: 0 };
                players.push(player);
                addPlayerToList(player);
                playerNameInput.value = "";

                // If first player, set as active
                if (players.length === 1) {
                    highlightActivePlayer();
                }
            });
        }

        // Voeg speler toe aan de lijst in de UI
        function addPlayerToList(player) {
            const li = document.createElement("li");
            li.id = `player-${player.name}`;
            li.textContent = `${player.name}: ${player.score}`;

            // Voeg reset knop toe
            const resetButton = document.createElement("button");
            resetButton.textContent = "Reset";
            resetButton.onclick = function() {
                player.score = 0;
                li.firstChild.textContent = `${player.name}: ${player.score}`;
            };

            li.appendChild(resetButton);
            playersList.appendChild(li);
        }

        // Highlight de actieve speler
        function highlightActivePlayer() {
            // Verwijder highlight van alle spelers
            playersList.querySelectorAll('li').forEach(li => {
                li.style.backgroundColor = 'transparent';
            });

            // Highlight de actieve speler
            const activePlayer = players[activePlayerIndex];
            const activeLi = document.getElementById(`player-${activePlayer.name}`);
            if (activeLi) {
                activeLi.style.backgroundColor = 'rgba(255, 255, 255, 0.2)';
            }

            // Update active player indicator
            activePlayerDiv.textContent = `Active Player: ${activePlayer.name}`;
        }

        // Render Functie
        function render(currentTime) {
            const deltaTime = currentTime - lastTime;
            lastTime = currentTime;

            glContext.clear(glContext.COLOR_BUFFER_BIT | glContext.DEPTH_BUFFER_BIT);

            // Automatische rotatie als niet aan het rollen
            if (!isRolling) {
                currentRotation.x += ROTATION_SPEED;
                currentRotation.y += ROTATION_SPEED;
            }

            // Update rotatie uniformen
            const uRotationX = glContext.getUniformLocation(program, "uRotationX");
            const uRotationY = glContext.getUniformLocation(program, "uRotationY");
            glContext.uniform1f(uRotationX, currentRotation.x);
            glContext.uniform1f(uRotationY, currentRotation.y);

            // Bind texturen
            for (let i = 0; i < textures.length; i++) {
                glContext.activeTexture(glContext.TEXTURE0 + i);
                glContext.bindTexture(glContext.TEXTURE_2D, textures[i]);
            }

            // Render de kubus (dobbelsteen)
            glContext.bindVertexArray(vao);
            glContext.drawArrays(glContext.TRIANGLES, 0, 36);

            requestAnimationFrame(render);
        }

        // Dobbelsteen Rollen
        function rollDie() {
            if (players.length === 0) {
                alert("Voeg eerst een speler toe!");
                return;
            }

            isRolling = true;

            // Genereer een willekeurig nummer tussen 1 en 6
            const randomNumber = Math.floor(Math.random() * 6) + 1;
            console.log(`Gegooid: ${randomNumber}`);

            // Update de score van de actieve speler
            const activePlayer = players[activePlayerIndex];
            activePlayer.score += randomNumber;
            const playerLi = document.getElementById(`player-${activePlayer.name}`);
            if (playerLi) {
                playerLi.firstChild.textContent = `${activePlayer.name}: ${activePlayer.score}`;
            }

            // Bepaal de eindrotatie zodat de juiste zijde naar boven komt
            const rotations = {
                1: { x: 0, y: 0 },
                2: { x: Math.PI / 2, y: 0 },
                3: { x: Math.PI, y: 0 },
                4: { x: -Math.PI / 2, y: 0 },
                5: { x: 0, y: Math.PI / 2 },
                6: { x: 0, y: -Math.PI / 2 }
            };

            const target = rotations[randomNumber];
            // Voeg extra rotaties toe voor realisme
            const extraRotations = Math.floor(Math.random() * 4) + 2; // 2 tot 5 extra rotaties
            targetRotation.x = currentRotation.x + target.x + (extraRotations * 2 * Math.PI);
            targetRotation.y = currentRotation.y + target.y + (extraRotations * 2 * Math.PI);

            // Animatie parameters
            const duration = 2000; // 2 seconden
            const startRotation = { ...currentRotation };
            const deltaRotation = { 
                x: targetRotation.x - startRotation.x,
                y: targetRotation.y - startRotation.y
            };
            const startTime = performance.now();

            // Easing functie (easeOutCubic)
            function easeOutCubic(t) {
                return 1 - Math.pow(1 - t, 3);
            }

            // Animatie functie met Easing
            function animate(time) {
                const elapsed = time - startTime;
                const t = Math.min(elapsed / duration, 1);
                const easedT = easeOutCubic(t);

                currentRotation.x = startRotation.x + deltaRotation.x * easedT;
                currentRotation.y = startRotation.y + deltaRotation.y * easedT;

                glContext.uniform1f(uRotationX, currentRotation.x);
                glContext.uniform1f(uRotationY, currentRotation.y);

                glContext.clear(glContext.COLOR_BUFFER_BIT | glContext.DEPTH_BUFFER_BIT);
                for (let i = 0; i < textures.length; i++) {
                    glContext.activeTexture(glContext.TEXTURE0 + i);
                    glContext.bindTexture(glContext.TEXTURE_2D, textures[i]);
                }
                glContext.bindVertexArray(vao);
                glContext.drawArrays(glContext.TRIANGLES, 0, 36);

                if (t < 1) {
                    requestAnimationFrame(animate);
                } else {
                    isRolling = false;
                    // Wissel naar de volgende speler
                    activePlayerIndex = (activePlayerIndex + 1) % players.length;
                    highlightActivePlayer();
                }
            }

            requestAnimationFrame(animate);
        }

        // Matrix Hulpfuncties
        function perspective(fov, aspect, near, far) {
            const f = 1.0 / Math.tan(fov / 2);
            const nf = 1 / (near - far);
            const out = new Float32Array(16);
            out[0] = f / aspect;
            out[1] = 0;
            out[2] = 0;
            out[3] = 0;
            out[4] = 0;
            out[5] = f;
            out[6] = 0;
            out[7] = 0;
            out[8] = 0;
            out[9] = 0;
            out[10] = (far + near) * nf;
            out[11] = -1;
            out[12] = 0;
            out[13] = 0;
            out[14] = (2 * far * near) * nf;
            out[15] = 0;
            return out;
        }

        function translate(x, y, z) {
            const out = new Float32Array(16);
            out[0] = 1;
            out[1] = 0;
            out[2] = 0;
            out[3] = 0;
            out[4] = 0;
            out[5] = 1;
            out[6] = 0;
            out[7] = 0;
            out[8] = 0;
            out[9] = 0;
            out[10] = 1;
            out[11] = 0;
            out[12] = x;
            out[13] = y;
            out[14] = z;
            out[15] = 1;
            return out;
        }
    </script>
</body>
</html>
